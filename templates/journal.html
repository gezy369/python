pnlChart{% extends "base.html" %}
{% block title %}Journal{% endblock %}
{% block content %}

<h2>Trade Journal</h2>

<!-- Top controls -->
<div style="margin-bottom:10px; display:flex; align-items:center; gap:8px;">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <button onclick="applyDateFilter()">Apply Dates</button>
  <button onclick="resetAll()">Reset</button>
</div>

<!-- Layout -->
<div style="display:flex; gap:20px; align-items:flex-start;">

  <!-- Table -->
  <div style="flex:2;">
    <table id="tradeTable">
      <thead><tr id="headerRow"></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Charts -->
  <div style="flex:1; display:flex; flex-direction:column; gap:30px;">
    <canvas id="pnlChart" height="200"></canvas>
    <canvas id="winRateChart" height="200"></canvas>
    <canvas id="winRateSymbolChart" height="200"></canvas>
    <canvas id="biggestTradeChart" height="200"></canvas>
    <canvas id="drawdownChart" height="200"></canvas>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
let originalData = [];
let charts = {};

// Columns
const COLUMN_NAMES = {
  id:"ID", symbol:"Symbol", boughtTimestamp:"Bought", soldTimestamp:"Sold",
  duration:"Duration", side:"Side", qty:"Qty",
  buyPrice:"Buy Price", sellPrice:"Sell Price", pnl:"PnL"
};

const COLUMN_ORDER = [
  "id","symbol","boughtTimestamp","soldTimestamp",
  "duration","side","qty","buyPrice","sellPrice","pnl"
];

// Fetch data
fetch("/api/trades")
  .then(r => r.json())
  .then(data => {
    originalData = data.map(t => ({
      ...t,
      boughtTimestamp: new Date(t.boughtTimestamp),
      soldTimestamp: new Date(t.soldTimestamp)
    }));
    buildHeaders();
    applyFiltersAndRender();
  });

/* ---------- Formatting ---------- */
const pad = n => String(n).padStart(2,"0");

function formatDateTime(d){
  return `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}

function formatDateOnly(d){
  return `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())}`;
}

function formatPnL(v){
  const n = Number(v);
  if (isNaN(n)) return "";
  const f = Math.abs(n).toLocaleString("en-US",{minimumFractionDigits:2});
  return n < 0 ? `($${f})` : `$${f}`;
}

/* ---------- Table ---------- */
function buildHeaders(){
  const tr = document.getElementById("headerRow");
  tr.innerHTML = "";
  COLUMN_ORDER.forEach(col=>{
    const th = document.createElement("th");
    th.textContent = COLUMN_NAMES[col];
    const input = document.createElement("input");
    input.placeholder = "Filter";
    input.onkeyup = applyFiltersAndRender;
    th.append(document.createElement("br"), input);
    tr.appendChild(th);
  });
}

function buildRows(data){
  const tbody = document.querySelector("#tradeTable tbody");
  tbody.innerHTML = "";

  data.forEach(row=>{
    const tr = document.createElement("tr");

    tr.ondblclick = () => openTradeInTradingView(row);

    COLUMN_ORDER.forEach(col=>{
      const td = document.createElement("td");
      if(col==="pnl"){
        td.textContent = formatPnL(row[col]);
        td.className = Number(row[col])>=0 ? "pnl-positive" : "pnl-negative";
      }
      else if(col==="boughtTimestamp" || col==="soldTimestamp"){
        td.textContent = formatDateTime(row[col]);
      }
      else td.textContent = row[col] ?? "";
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });
}

/* ---------- Filters ---------- */
function applyDateFilter(){ applyFiltersAndRender(); }

function applyFiltersAndRender(){
  const inputs = document.querySelectorAll("th input");
  const fromVal = dateFrom.value;
  const toVal = dateTo.value;

  let data = [...originalData];

  if(fromVal || toVal){
    const from = fromVal ? new Date(fromVal) : null;
    const to = toVal ? new Date(toVal) : null;
    data = data.filter(t=>{
      const d = t.boughtTimestamp;
      if(from && d < from) return false;
      if(to && d > to) return false;
      return true;
    });
  }

  inputs.forEach((i,idx)=>{
    if(!i.value) return;
    const col = COLUMN_ORDER[idx];
    data = data.filter(r=>String(r[col]??"").toLowerCase().includes(i.value.toLowerCase()));
  });

  buildRows(data);
  updateCharts(data);
}

function resetAll(){
  document.querySelectorAll("th input").forEach(i=>i.value="");
  dateFrom.value = "";
  dateTo.value = "";
  buildRows(originalData);
  updateCharts(originalData);
}

/* ---------- Charts ---------- */
function updateCharts(data){
  Object.values(charts).forEach(c=>c.destroy());
  charts = {};

  // --- DAILY CUMULATIVE PNL ---
  const daily = {};
  [...data].sort((a,b)=>a.boughtTimestamp-b.boughtTimestamp)
    .forEach(t=>{
      const d = formatDateOnly(t.boughtTimestamp);
      daily[d] = (daily[d] || 0) + Number(t.pnl || 0);
    });

  let running = 0;
  const labels = [];
  const values = [];

  Object.keys(daily).sort().forEach(d=>{
    running += daily[d];
    labels.push(d);
    values.push(running);
  });

  charts.pnlChart = new Chart(pnlChart,{
    type:"line",
    data:{labels,datasets:[{label:"Cumulative PnL",data:values,fill:true,borderColor:"green"}]},
    options:{plugins:{legend:{display:false}}}
  });

  // Win rate
  const wins = data.filter(d=>d.pnl>0).length;
  const losses = data.length - wins;
  charts.winRateChart = new Chart(winRateChart,{
    type:"doughnut",
    data:{labels:["Wins","Losses"],datasets:[{data:[wins,losses]}]}
  });

  // Win rate per symbol
  const perSym = {};
  data.forEach(t=>{
    perSym[t.symbol] ??= {w:0,t:0};
    if(t.pnl>0) perSym[t.symbol].w++;
    perSym[t.symbol].t++;
  });
  charts.winRateSymbolChart = new Chart(winRateSymbolChart,{
    type:"bar",
    data:{
      labels:Object.keys(perSym),
      datasets:[{label:"Win %",data:Object.values(perSym).map(v=>v.w/v.t*100)}]
    },
    options:{scales:{y:{max:100,beginAtZero:true}}}
  });

  // Biggest win/loss
  charts.biggestTradeChart = new Chart(biggestTradeChart,{
    type:"bar",
    data:{
      labels:["Biggest Win","Biggest Loss"],
      datasets:[{data:[Math.max(...data.map(d=>d.pnl)),Math.min(...data.map(d=>d.pnl))]}]
    }
  });

  // Drawdown
  let peak = 0, maxDD = 0;
  values.forEach(v=>{ peak=Math.max(peak,v); maxDD=Math.max(maxDD,peak-v); });
  charts.drawdownChart = new Chart(drawdownChart,{
    type:"bar",
    data:{labels:["Max Drawdown"],datasets:[{data:[maxDD]}]}
  });
}

/* ---------- TradingView ---------- */
function openTradeInTradingView(trade, timeframe=5){
  const symbol = `CME:${trade.symbol}1!`;
  const ts = trade.boughtTimestamp.getTime();
  window.open(
    `https://www.tradingview.com/chart/?symbol=${encodeURIComponent(symbol)}&interval=${timeframe}&timestamp=${ts}`,
    "_blank"
  );
}
</script>

{% endblock %}
