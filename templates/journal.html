{% extends "base.html" %}

{% block title %}Journal{% endblock %}

{% block content %}

<h2>Trade Journal</h2>

<!-- Top controls: date range + buttons -->
<div style="margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <button onclick="applyDateFilter()">Apply Dates</button>
  <button onclick="resetSort()">Reset Sorting/Filters</button>
</div>

<!-- Container for table + charts -->
<div style="display: flex; gap: 20px; align-items: flex-start;">
  
  <!-- Left: table -->
  <div style="flex: 2;">
    <table id="tradeTable">
      <thead><tr id="headerRow"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
  
  <!-- Right: charts -->
  <div style="flex: 1; display: flex; flex-direction: column; gap: 30px;">
    <canvas id="pnlChart" height="200"></canvas>
    <canvas id="winRateChart" height="200"></canvas>
    <canvas id="winRateSymbolChart" height="200"></canvas>
    <canvas id="biggestTradeChart" height="200"></canvas>
    <canvas id="drawdownChart" height="200"></canvas>
  </div>
</div>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
let originalData = [];
let currentSort = { column: null, direction: null };
let charts = {};

// Column display names
const COLUMN_NAMES = {
  id: "ID", symbol: "Symbol", boughtTimestamp: "Bought",
  soldTimestamp: "Sold", duration: "Duration", side: "Side",
  qty: "Qty", buyPrice: "Buy Price", sellPrice: "Sell Price", pnl: "PnL"
};

// Column order
const COLUMN_ORDER = ["id","symbol","boughtTimestamp","soldTimestamp","duration","side","qty","buyPrice","sellPrice","pnl"];

// Fetch trades
fetch("/api/trades")
  .then(res => res.json())
  .then(data => {
    // Convert timestamps to Date
    originalData = data.map(r => ({
      ...r,
      boughtTimestamp: new Date(r.boughtTimestamp),
      soldTimestamp: new Date(r.soldTimestamp)
    }));

    buildHeaders(COLUMN_ORDER);
    buildRows(originalData, COLUMN_ORDER);
    updateCharts(originalData);
  });

/* ---------- Formatting ---------- */
function formatDateTime(d) {
  if (!(d instanceof Date) || isNaN(d)) return "";
  const pad = n => String(n).padStart(2,"0");
  return `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}

function formatPnL(value) {
  const num = Number(value);
  if (isNaN(num)) return "";
  const formatted = Math.abs(num).toLocaleString("en-US",{minimumFractionDigits:2, maximumFractionDigits:2});
  return num < 0 ? `($${formatted})` : `$${formatted}`;
}

/* ---------- Table ---------- */
function buildHeaders(columns) {
  const thead = document.getElementById("headerRow");
  thead.innerHTML = "";
  columns.forEach(col => {
    const th = document.createElement("th");

    const label = document.createElement("span");
    label.textContent = COLUMN_NAMES[col] || col;
    label.className = "sortable";
    label.onclick = () => sortTable(col, label);

    const input = document.createElement("input");
    input.placeholder = "Filter";
    input.onkeyup = filterTable;
    input.onclick = input.onmousedown = e => e.stopPropagation();

    th.append(label, document.createElement("br"), input);
    thead.appendChild(th);
  });
}

function buildRows(data, columns) {
  const tbody = document.querySelector("#tradeTable tbody");
  tbody.innerHTML = "";

  data.forEach(row => {
    const tr = document.createElement("tr");
    columns.forEach(col => {
      const td = document.createElement("td");

      if (col === "pnl") {
        td.textContent = formatPnL(row[col]);
        td.className = Number(row[col])>=0 ? "pnl-positive" : "pnl-negative";
      } else if (col==="boughtTimestamp" || col==="soldTimestamp") {
        td.textContent = formatDateTime(row[col]);
      } else td.textContent = row[col] ?? "";

      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

/* ---------- Sorting ---------- */
function sortTable(column,label){
  document.querySelectorAll(".sortable").forEach(h=>h.classList.remove("active"));
  label.classList.add("active");
  const direction = currentSort.column===column && currentSort.direction==="asc"?"desc":"asc";
  currentSort={column,direction};

  const sorted = [...originalData].sort((a,b)=>{
    if(a[column]==null)return 1;
    if(b[column]==null)return -1;

    if(a[column] instanceof Date) return direction==="asc"?a[column]-b[column]:b[column]-a[column];
    if(!isNaN(a[column])) return direction==="asc"?a[column]-b[column]:b[column]-a[column];
    return direction==="asc"?String(a[column]).localeCompare(String(b[column])):String(b[column]).localeCompare(String(a[column]));
  });

  buildRows(sorted,COLUMN_ORDER);
  updateCharts(sorted);
}

/* ---------- Filtering ---------- */
function applyDateFilter(){ filterTable(); }

function filterTable(){
  const inputs = document.querySelectorAll("th input");
  const dateFrom = document.getElementById("dateFrom").value;
  const dateTo = document.getElementById("dateTo").value;
  let filtered = [...originalData];

  // Date filter
  if(dateFrom||dateTo){
    const from=dateFrom?new Date(dateFrom):null;
    const to=dateTo?new Date(dateTo):null;
    filtered = filtered.filter(d=>{
      const dt=d.boughtTimestamp;
      if(from && dt<from) return false;
      if(to && dt>to) return false;
      return true;
    });
  }

  // Column filters
  inputs.forEach((input,index)=>{
    if(!input.value) return;
    const col=COLUMN_ORDER[index];
    filtered = filtered.filter(r=>String(r[col]??"").toLowerCase().includes(input.value.toLowerCase()));
  });

  buildRows(filtered,COLUMN_ORDER);
  updateCharts(filtered);
}

/* ---------- Reset ---------- */
function resetSort(){
  currentSort={column:null,direction:null};
  document.querySelectorAll(".sortable").forEach(h=>h.classList.remove("active"));
  document.querySelectorAll("th input").forEach(i=>i.value="");
  document.getElementById("dateFrom").value="";
  document.getElementById("dateTo").value="";
  buildRows(originalData,COLUMN_ORDER);
  updateCharts(originalData);
}

/* ---------- Charts ---------- */
const chartsConfig=[
  {id:"pnlChart",type:"line",label:"PnL over time",dataFunc:data=>({labels:data.map(d=>formatDateTime(d.boughtTimestamp)),datasets:[{label:"PnL",data:data.map(d=>d.pnl),borderColor:"green",backgroundColor:"rgba(0,255,0,0.2)",fill:true,tension:0.2}]}),options:{responsive:true,plugins:{legend:{display:false}}}},
  {id:"winRateChart",type:"doughnut",label:"Win/Loss Rate",dataFunc:data=>{const w=data.filter(d=>d.pnl>0).length,l=data.filter(d=>d.pnl<=0).length;return {labels:["Wins","Losses"],datasets:[{data:[w,l],backgroundColor:["green","red"]}]};},options:{responsive:true}},
  {id:"winRateSymbolChart",type:"bar",label:"Win Rate per Symbol",dataFunc:data=>{const s={};data.forEach(d=>{s[d.symbol]??={win:0,total:0};if(d.pnl>0)s[d.symbol].win++;s[d.symbol].total++;});return {labels:Object.keys(s),datasets:[{label:"Win %",data:Object.values(s).map(v=>v.win/v.total*100),backgroundColor:"blue"}]};},options:{responsive:true,scales:{y:{beginAtZero:true,max:100}}}},
  {id:"biggestTradeChart",type:"bar",label:"Biggest Win/Loss",dataFunc:data=>{const max=Math.max(...data.map(d=>d.pnl)),min=Math.min(...data.map(d=>d.pnl));return {labels:["Biggest Win","Biggest Loss"],datasets:[{label:"PnL",data:[max,min],backgroundColor:["green","red"]}]};},options:{responsive:true,scales:{y:{beginAtZero:false}}}},
  {id:"drawdownChart",type:"bar",label:"Max Drawdown",dataFunc:data=>{let peak=0,drawdowns=[];data.forEach(d=>{peak=Math.max(peak,d.pnl);drawdowns.push(peak-d.pnl);});return {labels:["Max Drawdown"],datasets:[{label:"PnL",data:[Math.max(...drawdowns)],backgroundColor:"orange"}]};},options:{responsive:true,scales:{y:{beginAtZero:true}}}}
];

function updateCharts(data){
  chartsConfig.forEach(cfg=>{
    if(charts[cfg.id]) charts[cfg.id].destroy();
    const ctx=document.getElementById(cfg.id);
    charts[cfg.id]=new Chart(ctx,{type:cfg.type,data:cfg.dataFunc(data),options:cfg.options});
  });
}
</script>

{% endblock %}
