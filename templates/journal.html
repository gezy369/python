{% extends "base.html" %}

{% block title %}Journal{% endblock %}

{% block content %}

<h2>Trade Journal</h2>

<button id="resetSort" onclick="resetSort()">Reset sorting</button>

<div style="margin-bottom: 10px;">
  From:
  <input type="date" id="dateFrom">
  To:
  <input type="date" id="dateTo">
</div>

<table id="tradeTable">
  <thead>
    <tr id="headerRow"></tr>
  </thead>
  <tbody></tbody>
</table>

<script>
let originalData = [];
let currentSort = { column: null, direction: null };

// Mapping for display names
const COLUMN_NAMES = {
  id: "ID",
  symbol: "Symbol",
  boughtTimestamp: "Bought",
  soldTimestamp: "Sold",
  duration: "Duration",
  side: "Side",
  qty: "Qty",
  buyPrice: "Buy Price",
  sellPrice: "Sell Price",
  pnl: "PnL"
};


//Trade table columns order
const COLUMN_ORDER = [
  "id",
  "symbol",
  "boughtTimestamp",
  "soldTimestamp",
  "duration",
  "side",
  "qty",
  "buyPrice",
  "sellPrice",
  "pnl"
];
//fetch data
fetch("/api/trades")
  .then(res => res.json())
  .then(data => {
    // Convert boughtTimestamp and soldTimestamp to Date objects
    originalData = data.map(row => ({
      ...row,
      boughtTimestamp: new Date(row.boughtTimestamp),
      soldTimestamp: new Date(row.soldTimestamp)
    }));

    buildHeaders(COLUMN_ORDER);         // headers in correct order
    buildRows(originalData, COLUMN_ORDER);      // rows in correct order
  });





function buildHeaders(columns) {
  const thead = document.getElementById("headerRow");
  thead.innerHTML = "";

  columns.forEach(col => {
    const th = document.createElement("th");

    // Header label (clickable for sorting)
    const label = document.createElement("span");
    label.textContent = COLUMN_NAMES[col] || col; // Use friendly name if exists
    label.className = "sortable";
    label.onclick = () => sortTable(col, label);

    // Filter input
    const input = document.createElement("input");
    input.placeholder = "Filter";
    input.onkeyup = filterTable;
    input.onclick = e => e.stopPropagation();       // prevent sorting when typing
    input.onmousedown = e => e.stopPropagation();   // prevent sorting on click

    th.appendChild(label);
    th.appendChild(document.createElement("br"));
    th.appendChild(input);

    thead.appendChild(th);
  });
}



function buildRows(data, columnsOrder) {
    const tbody = document.querySelector("#tradeTable tbody");
    tbody.innerHTML = "";

    // If no column order provided, fallback to keys from data
    const columns = columnsOrder || Object.keys(data[0] || {});

    data.forEach(row => {
        const tr = document.createElement("tr");

        columns.forEach(col => {
        const td = document.createElement("td");

        // Format PnL
        if (col === "pnl") {
            td.textContent = formatPnL(row[col]);
        } else {
            td.textContent = row[col] ?? "";  // fallback to empty string if undefined
        }

        // Add coloring for PnL
        if (col.toLowerCase() === "pnl") {
            td.className = Number(row[col]) >= 0
            ? "pnl-positive"
            : "pnl-negative";
        }

        tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
    }

  // Rows
  data.forEach(row => {
    const tr = document.createElement("tr");

    columns.forEach(col => {
      const td = document.createElement("td");
      td.textContent = row[col];

      // Conditional PnL coloring
      if (col.toLowerCase() === "pnl") {
        const val = Number(row[col]);
        td.className = val >= 0 ? "pnl-positive" : "pnl-negative";
      }

      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });


// Sorting
function sortTable(column, label) {
  const headers = document.querySelectorAll(".sortable");
  headers.forEach(h => h.classList.remove("active"));

  label.classList.add("active");

  const direction =
    currentSort.column === column && currentSort.direction === "asc"
      ? "desc"
      : "asc";

  currentSort = { column, direction };

  const sorted = [...originalData].sort((a, b) => {
    if (a[column] == null) return 1;
    if (b[column] == null) return -1;

    if (!isNaN(a[column])) {
      return direction === "asc"
        ? a[column] - b[column]
        : b[column] - a[column];
    }

    return direction === "asc"
      ? String(a[column]).localeCompare(String(b[column]))
      : String(b[column]).localeCompare(String(a[column]));
  });

  buildRows(sorted);
}

// Reset sorting
function resetSort() {
  currentSort = { column: null, direction: null };

  // Remove active sort highlight
  document.querySelectorAll(".sortable")
    .forEach(h => h.classList.remove("active"));

  // Clear column filters
  document.querySelectorAll("th input")
    .forEach(input => input.value = "");

  // Clear date filters
  document.getElementById("dateFrom").value = "";
  document.getElementById("dateTo").value = "";

  // Restore original data
  buildRows(originalData);
}


// Filtering
function filterTable() {
  const inputs = document.querySelectorAll("th input");
  const dateFrom = document.getElementById("dateFrom").value;
  const dateTo = document.getElementById("dateTo").value;

  let filtered = [...originalData];

  // Column filters
  inputs.forEach((input, index) => {
    if (!input.value) return;
    const col = COLUMN_ORDER[index]; // Use the correct column name

    filtered = filtered.filter(row =>
      String(row[col] ?? "")
        .toLowerCase()
        .includes(input.value.toLowerCase())
    );
  });

  // Date range filter
  if (dateFrom || dateTo) {
    const fromDate = dateFrom ? new Date(dateFrom) : null;
    const toDate = dateTo ? new Date(dateTo) : null;

    filtered = filtered.filter(row => {
      const rowDate = row.boughtTimestamp; // Already a Date object

      if (fromDate && rowDate < fromDate) return false;
      if (toDate && rowDate > toDate) return false;

      return true;
    });
  }

  buildRows(filtered, COLUMN_ORDER);
}



//Format PnL for it to be financial
function formatPnL(value) {
  const num = Number(value);
  if (isNaN(num)) return "";

  const formatted = Math.abs(num).toLocaleString("en-US", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });

  return num < 0 ? `($${formatted})` : `$${formatted}`;
}


</script>

{% endblock %}
