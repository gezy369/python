{% extends "base.html" %}
{% block title %}Journal{% endblock %}
{% block content %}

<h2>Trade Journal</h2>

<!-- ================= CONTROLS ================= -->
<div style="margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
  <label>From: <input type="date" id="dateFrom"></label>
  <label>To: <input type="date" id="dateTo"></label>
  <button onclick="applyFiltersAndRender()">Apply Dates</button>
  <button onclick="resetFilters()">Reset filters</button>

  <div style="width:20px;"></div>

  <!-- Setup filter -->
  <select id="setupFilter" multiple onchange="applyFiltersAndRender()" style="min-width:150px; height:100px;">
    <!-- options populated dynamically -->
  </select>
<!-- Strategy filter -->
 <select id="strategyFilter" onchange="applyFiltersAndRender()">
  <option value="">All strategies</option>
</select>

<!-- Delete button -->
  <button onclick="deleteSelected()" style="background:#c0392b;color:white;">
    Delete selected
  </button>
</div>
<!-- Table -->
<div style="display:flex; gap:20px; align-items:flex-start;">
  <div style="flex:2;">
    <table id="tradeTable">
      <thead><tr id="headerRow"></tr></thead>
      <tbody></tbody>
    </table>
  </div>
<!-- Pnl chart-->
  <div style="flex:1; display:flex; flex-direction:column; gap:30px;">
    <div style="height:220px;"><canvas id="pnlChart"></canvas></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
let originalData = [];
let charts = {};
let openRow = null;
let STRATEGIES = [];
let SETUPS = [];

/* ---------------- COLUMNS & FORMAT ---------------- */
const COLUMN_ORDER = ["select","symbol","entryTimestamp","exitTimestamp","duration","side","qty","entryPrice","exitPrice","pnl"];
const COLUMN_NAMES = { select:"", symbol:"Symbol", entryTimestamp:"Entry Time", exitTimestamp:"Exit Time", duration:"Duration", side:"Side", qty:"Qty", entryPrice:"Entry Price", exitPrice:"Exit Price", pnl:"PnL" };
const pad = n => String(n).padStart(2,"0");
const formatDate = d => `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
const formatPnL = v => { const n = Number(v)||0; const f = Math.abs(n).toLocaleString("en-US",{minimumFractionDigits:2}); return n < 0 ? `($${f})` : `$${f}`; };

/* ---------------- FETCH DATA ---------------- */
Promise.all([
  fetch("/api/strategies").then(r => r.json()),
  fetch("/api/setups").then(r => r.json()),
  fetch("/api/trade_setups").then(r => r.json()),
  fetch("/api/trades").then(r => r.json())
]).then(([strategies, setups, tradeSetups, trades]) => {

  STRATEGIES = strategies;
  SETUPS = setups;

  // Populate the setup filter dropdown
  const setupFilter = document.getElementById("setupFilter");
  if (setupFilter) {
    setupFilter.innerHTML = ""; // clear previous
    const allOption = document.createElement("option");
    allOption.value = ""; // empty value = all
    allOption.textContent = "All setups";
    setupFilter.appendChild(allOption);

    SETUPS.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s.id;
      opt.textContent = s.setup_name;
      setupFilter.appendChild(opt);
    });
  }

  // ---------- STRATEGY FILTER ----------
  const strategyFilter = document.getElementById("strategyFilter");
  if (strategyFilter) {
    strategyFilter.innerHTML = ""; // clear previous

    const allOption = document.createElement("option");
    allOption.value = ""; // empty value = all
    allOption.textContent = "All strategies";
    strategyFilter.appendChild(allOption);

    STRATEGIES.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s.id;
      opt.textContent = s.strategy_name;
      strategyFilter.appendChild(opt);
    });
  }

  // Attach setups to trades
  originalData = trades.map(t => ({
    ...t,
    entryTimestamp: new Date(t.entryTimestamp),
    exitTimestamp: new Date(t.exitTimestamp),
    setups: tradeSetups
      .filter(ts => ts.key_trade_id === t.id)
      .map(ts => ts.key_setup_id) // just IDs for now
  }));

  buildHeaders();
  applyFiltersAndRender();
});

function resetFilters() {
  // reset date inputs
  const dateFrom = document.getElementById("dateFrom");
  const dateTo = document.getElementById("dateTo");
  if (dateFrom) dateFrom.value = "";
  if (dateTo) dateTo.value = "";

  // reset column filters
  document.querySelectorAll("th input[data-col]").forEach(input => input.value = "");

  // reset setup filter (multi-select)
  const setupFilter = document.getElementById("setupFilter");
  if (setupFilter) {
    Array.from(setupFilter.options).forEach(opt => opt.selected = opt.value === "");
  }

  // reset strategy filter (single-select)
  const strategyFilter = document.getElementById("strategyFilter");
  if (strategyFilter) strategyFilter.value = "";

  // re-render table + chart
  applyFiltersAndRender();
}

/* ---------------- HEADERS ---------------- */
function buildHeaders(){
  const tr = document.getElementById("headerRow"); tr.innerHTML="";
  COLUMN_ORDER.forEach(col=>{
    const th = document.createElement("th");
    if(col==="select"){
      const cb=document.createElement("input"); cb.type="checkbox"; cb.onclick=e=>{ document.querySelectorAll(".row-select").forEach(x=>x.checked=e.target.checked); }; th.appendChild(cb);
    } else {
      th.textContent = COLUMN_NAMES[col] ?? col;
      const input=document.createElement("input"); input.placeholder="Filter"; input.dataset.col=col; input.onkeyup=applyFiltersAndRender; th.append(document.createElement("br"), input);
    }
    tr.appendChild(th);
  });
}

/* ---------------- RENDER ROWS ---------------- */
function buildRows(data){
  const tbody=document.querySelector("#tradeTable tbody"); tbody.innerHTML="";
  data.forEach(row=>{
    const tr=document.createElement("tr"); tr.className="trade-row"; tr.onclick=()=>toggleTradeDetails(tr,row);
    COLUMN_ORDER.forEach(col=>{
      const td=document.createElement("td");
      if(col==="select"){ const cb=document.createElement("input"); cb.type="checkbox"; cb.className="row-select"; cb.dataset.id=row.id; cb.addEventListener("click",e=>e.stopPropagation()); td.appendChild(cb); }
      else if(col==="pnl"){ const v=Number(row[col])||0; td.textContent=formatPnL(v); td.className=v>=0?"pnl-positive":"pnl-negative"; }
      else if(col.includes("Timestamp")) td.textContent=formatDate(row[col]);
      else td.textContent=row[col]??"";
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

/* ---------------- TAGS ---------------- */
function renderStrategyTag(strategyId){
  if(!strategyId) return `<span class="strategy-tag muted" data-remove-strategy>None ×</span>`;
  const s=STRATEGIES.find(x=>x.id===strategyId); if(!s) return "";
  return `<span class="strategy-tag" style="background:${s.color}" data-remove-strategy>${s.strategy_name} ×</span>`;
}

function renderSetupTags(trade) {
  if (!trade.setups?.length) return `<span class="setup-tag muted">No setup</span>`;

  return trade.setups.map(id => {
    const s = SETUPS.find(x => x.id === id);
    if (!s) return "";

    return `
      <span class="setup-tag" style="background:${s.color};">
        ${s.setup_name}
        <span class="tag-remove"
              onclick="removeSetup(event, ${trade.id}, ${id})">✕</span>
      </span>
    `;
  }).join("");
}



function removeSetup(e, tradeId, setupId){
  e.stopPropagation();

  fetch("/api/trade_setups", {
    method: "DELETE",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      trade_id: tradeId,
      setup_id: setupId
    })
  })
  .then(() => {
  const trade = originalData.find(t => t.id === tradeId);
  trade.setups = trade.setups.filter(id => id !== setupId);

  // re-render tags only
  const container = openRow?.panel?.querySelector(".setup-tag-container");
  if (container) {
    container.innerHTML = renderSetupTags(trade);
  }
});

}

function refreshOpenTrade(){
  if (!openRow) return;

  const { tr, detailsTr } = openRow;
  const tradeId = tr.querySelector(".row-select")?.dataset.id;
  const trade = originalData.find(t => t.id == tradeId);

  closeDetails();
  toggleTradeDetails(tr, trade);
}


/* ---------------- TOGGLE DETAILS ---------------- */
function toggleTradeDetails(tr, trade){
  if(openRow && openRow.tr===tr){ closeDetails(); return; }
  closeDetails(); tr.classList.add("expanded");

  const strategyOptions = [`<option value="">No strategy</option>`, ...STRATEGIES.map(s=>`<option value="${s.id}" ${s.id===trade.key_strategies_id?"selected":""}>${s.strategy_name}</option>`)].join("");
  const detailsTr=document.createElement("tr"); detailsTr.className="trade-details-row";
  const td=document.createElement("td"); td.colSpan=COLUMN_ORDER.length;

  td.innerHTML=`
    <div class="trade-details">
      <div class="trade-details-grid">
        <div>
          <h4>Trade</h4>
          <div><strong>Symbol:</strong> ${trade.symbol}</div>
          <div><strong>Side:</strong> ${trade.side}</div>
          <div><strong>Qty:</strong> ${trade.qty}</div>
          <div><strong>Entry:</strong> ${formatDate(trade.entryTimestamp)}</div>
          <div><strong>Exit:</strong> ${formatDate(trade.exitTimestamp)}</div>
          <div><strong>PnL:</strong> ${formatPnL(trade.pnl)}</div>
        </div>

        <div>
          <h4>Strategy</h4>
          <select class="trade-strategy" style="width:100%;">${strategyOptions}</select>
          <div class="strategy-tag-container" style="margin-top:6px;">${renderStrategyTag(trade.key_strategies_id)}</div>
        </div>

        <div>
          <h4>Setups</h4>
          <select class="setup-add" style="width:100%;">
            <option value="">+ Add setup</option>
            ${SETUPS.map(s=>`<option value="${s.id}">${s.setup_name}</option>`).join("")}
          </select>
          <div class="setup-tag-container">
            ${renderSetupTags(trade)}
          </div>
        </div>
      </div>
    </div>
  `;

  detailsTr.appendChild(td); tr.after(detailsTr);
  const panel = td.querySelector(".trade-details"); panel.offsetHeight; requestAnimationFrame(()=>panel.classList.add("open"));
  openRow={tr,detailsTr,panel};

  // ---------- STRATEGY CHANGE ----------
  const strategySelect=td.querySelector(".trade-strategy");
  const strategyContainer=td.querySelector(".strategy-tag-container");
  strategySelect.addEventListener("change", ()=>{
    const val = strategySelect.value || null;
    fetch(`/api/trades/${trade.id}`, { method:"PATCH", headers:{"Content-Type":"application/json"}, body: JSON.stringify({ key_strategies_id: val }) });
    trade.key_strategies_id = val ? Number(val) : null;
    strategyContainer.innerHTML = renderStrategyTag(trade.key_strategies_id);
    attachStrategyRemoveHandler(trade, strategyContainer);
  });
  attachStrategyRemoveHandler(trade, strategyContainer);

  // ---------- SETUP ADD ----------
  const setupSelect = td.querySelector(".setup-add");
  const setupContainer = td.querySelector(".setup-tag-container");

  setupSelect.addEventListener("change", async () => {
  const setupId = setupSelect.value;
  if (!setupId) return;

  await fetch("/api/trade_setup", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      key_trade_id: trade.id,
      key_setup_id: setupId
    })
  });

    trade.setups.push(Number(setupId));   // ✅ keep IDs only

    setupContainer.innerHTML = renderSetupTags(trade);
    setupSelect.value = "";
  });

  attachSetupRemoveHandlers(trade, setupContainer);
}

/* ---------------- CHARTS -------------------- */
function renderPnLChart(data) {
  const ctx = document.getElementById("pnlChart");
  if (!ctx) return;

  // destroy previous chart
  if (charts.pnl) charts.pnl.destroy();

  // group pnl by date
  const byDate = {};
  data.forEach(t => {
    const d = t.entryTimestamp.toISOString().slice(0, 10); // YYYY-MM-DD
    byDate[d] = (byDate[d] || 0) + (Number(t.pnl) || 0);
  });

  const dates = Object.keys(byDate).sort();
  let cumulative = 0;
  const cumulativePnL = dates.map(d => {
    cumulative += byDate[d];
    return cumulative;
  });

  charts.pnl = new Chart(ctx, {
    type: "line",
    data: {
      labels: dates,
      datasets: [{
        label: "Cumulative PnL",
        data: cumulativePnL,
        borderColor: "#2ecc71",
        backgroundColor: "rgba(46, 204, 113, 0.15)",
        tension: 0.25,
        fill: true,
        pointRadius: 2
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false }
      },
      scales: {
        y: {
          ticks: {
            callback: v => `$${v.toLocaleString()}`
          }
        }
      }
    }
  });
}

function updatePnLChart(data) {
  const ctx = document.getElementById("pnlChart");
  if (!ctx) return;

  // group PnL by date
  const daily = {};
  data.forEach(t => {
    const d = t.entryTimestamp.toISOString().slice(0, 10);
    daily[d] = (daily[d] || 0) + (Number(t.pnl) || 0);
  });

  const dates = Object.keys(daily).sort();
  let cumulative = 0;
  const values = dates.map(d => (cumulative += daily[d]));

  // destroy previous chart
  if (charts.pnl) charts.pnl.destroy();

  charts.pnl = new Chart(ctx, {
    type: "line",
    data: {
      labels: dates,
      datasets: [{
        label: "Cumulative PnL",
        data: values,
        borderColor: "#2ecc71",
        backgroundColor: "rgba(46, 204, 113, 0.15)",
        fill: true,
        tension: 0.3
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { display: false }
      },
      scales: {
        y: {
          ticks: {
            callback: v => `$${v.toLocaleString()}`
          }
        }
      }
    }
  });
}

/* ---------------- REMOVE STRATEGY ---------------- */
function attachStrategyRemoveHandler(trade, container){
  const tag = container.querySelector("[data-remove-strategy]");
  if(tag){
    tag.addEventListener("click", ()=>{
      fetch(`/api/trades/${trade.id}`, { method:"PATCH", headers:{"Content-Type":"application/json"}, body:JSON.stringify({ key_strategies_id: null }) });
      trade.key_strategies_id = null;
      container.innerHTML = renderStrategyTag(null);
      attachStrategyRemoveHandler(trade, container);
    });
  }
}

/* ---------------- REMOVE SETUP ---------------- */
function attachSetupRemoveHandlers(trade, container){
  container.querySelectorAll(".setup-tag").forEach(tag=>{
    tag.addEventListener("click", async ()=>{
      const id = tag.dataset.tradeSetupId;
      await fetch(`/api/trade_setup/${id}`, { method:"DELETE" });
      trade.setups = trade.setups.filter(s => s.trade_setup_id != id);
      container.innerHTML = renderSetupTags(trade.setups);
      attachSetupRemoveHandlers(trade, container);
    });
  });
}

/* ---------------- CLOSE DETAILS ---------------- */
function closeDetails(){
  if(!openRow) return;
  const { tr, detailsTr, panel } = openRow;
  tr.classList.remove("expanded");
  panel.classList.remove("open");
  setTimeout(()=>detailsTr.remove(),250);
  openRow=null;
}

/* ---------------- FILTERS ---------------- */
function applyFiltersAndRender() {
  let data = [...originalData];

  // ---------- DATE FILTER ----------
  const from = dateFrom.value ? new Date(dateFrom.value) : null;
  const to   = dateTo.value   ? new Date(dateTo.value)   : null;

  if (from || to) {
    data = data.filter(t => {
      if (from && t.entryTimestamp < from) return false;
      if (to   && t.entryTimestamp > to)   return false;
      return true;
    });
  }

  // ---------- COLUMN FILTERS ----------
  document.querySelectorAll("th input[data-col]").forEach(input => {
    if (!input.value) return;
    const col = input.dataset.col;
    const val = input.value.toLowerCase();

    data = data.filter(r =>
      String(r[col] ?? "").toLowerCase().includes(val)
    );
  });

  // ---------- SETUP FILTER (multi) ----------
  const setupFilter = document.getElementById("setupFilter");
  const selectedSetups = setupFilter
    ? Array.from(setupFilter.selectedOptions)
        .map(o => Number(o.value))
        .filter(Boolean)
    : [];

  if (selectedSetups.length) {
    data = data.filter(t =>
      selectedSetups.every(id => t.setups?.includes(id))
    );
  }

  // ---------- STRATEGY FILTER (single) ----------
  const strategyFilter = document.getElementById("strategyFilter");
  const strategyId = strategyFilter?.value;

  if (strategyId) {
    data = data.filter(t => t.key_strategies_id == strategyId);
  }

  // ---------- SORT ----------
  data.sort((a, b) => a.entryTimestamp - b.entryTimestamp);

  // ---------- RENDER ----------
  buildRows(data);
  updatePnLChart(data);
}


</script>



{% endblock %}
